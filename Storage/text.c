#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", &i);
//	printf("%p\n", &arr[9]);
//	for (i = 0; i <= 12; i++)//越界访问
//	{
//		arr[i] = 0;//x86环境下观测
//		//debug版本死循环
//		//release版本没有死循环
//		//表明release版本有优化 release版本将i的内存地址放在了arr下方
//		printf("hehe\n");
//	}
//	return 0;
//}

//整型家族
//char
//	unsigned char
//	signed char
//short 
//	unsigned short
//	signed short
//int
//	unsigned int
//	signed int
//long
//	unsigned long
//	signed long

//浮点数家族
//float 
//double

//构造类型(自定义类型)
//	数组
//	struct 结构体类型
//	enum	枚举
//	union 联合体
//指针类型
//空类型
//void
//函数返回类型 void test()
//函数参数	void test (void)
//指针 void* p;

//int main()
//{
//	int arr[10];
//	int arr2[5];
//	return 0;
//}

//int main()
//{
//	int a = -10; //f6 ff ff ff
//	//原码
//	//10000000000000000000000000001010
//	//反码
//	//11111111111111111111111111110101
//	//补码
//	//11111111111111111111111111110110  
//	//内存存的是二进制补码
//	return 0;
//}

//数据在内存中以2进制的形式存储
//对于整数来说:
//整数的二进制有3中表现形式:原码 反码 补码
//正整数:原码 反码 补码  相同
//负整数:如上

//大端小端        
//大端(存储)模式，是指数据低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中;
//小端(存储)模式，是指数据低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中;


//大端字节序和小端字节序
//int main()
//{
//	int a = 0x11223344;//检查内存存储模式
//	return 0;
//}

//写一个程序判断字节序
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*) &a;
//	if (1 == *p)
//		return 1;
//	else
//		return 0;
//}
//优化
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*) &a;
//		return *p;//返回1表示小端，返回0表示大端
//}
//int main()
//{
//	int ret = check_sys();
//	if (1 == ret)
//	{
//		printf("小端\n");
//	}
//	else
//		printf("大端\n");
//	return 0;
//}


//1输出什么?
//int main()
//{
//	//char a = -1;
//	////10000000000000000000000000000001
//	////11111111111111111111111111111110
//	////11111111111111111111111111111111
//	////11111111
//	////整型提升
//	////11111111111111111111111111111111
//	//signed char b = -1;
//	////11111111
//	//unsigned char c = -1;
//	////11111111
//	////整型提升
//	////00000000000000000000000011111111
//	//printf("a=%d,b=%d,c=%d", a, b, c); //-1 -1 255
//
//	return 0;
//}

//补充
//1 char类型到底是signed char还是unsigned char?
//c标志没规定，取决与编译器
//int 是signed int 还是 unsigned int
//c规定signed int   signed short

//2输出什么?
//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000
//	//11111111111111111111111101111111
//	//11111111111111111111111110000000 -补码
//	//10000000
//	//-128
//	printf("%u\n", a);//%u以无符号整型打印 4,294,967,168
//	return 0;
//}   

//3输出什么?
//int main()
//{
//	char a = 128; 有符号的char取值范围 -128--127
//	//00000000000000000000000010000000 -  原反补相同
//	//10000000(内存看到10000000直接解析为-128)
//	//11111111111111111111111100000000
//	printf("%u\n", a);
//	return 0; //4,294,967,168
//}


//127+1  -> -128

//char类型的取值范围
//char 00000000 -> 0
//	   00000001	-> 1
//     00000010	-> 2
//	   .....
//	   01111111	-> 127 (max)
//     10000000 ->(直接被解析-128)
//     10000001	->10000000 -> 11111111	-127
//     10000010 ->11111101 -> 10000010  -2
//     .....
//     11111111	->11111110 -> 10000001  -1

//4 输出什么
//int main()
//{
//	int i = -20;
//	//1000000000000000000000010100
//	//1111111111111111111111101011
//	//1111111111111111111111101100
//	//0000000000000000000000001010
//	unsigned int j = 10;
//	//0000000000000000000000001010
//
//	//1111111111111111111111110110-补码
//	//1111111111111111111111110101-反码
//	//1000000000000000000000001010-原码
//	printf("%d\n", i + j);
//	return 0;
//}

//5
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--) //会陷入死循环
//	{
//		printf("%u\n", i);
//		//00000000000000000000000000001001   9
//		//00000000000000000000000000001000   8
//		//00000000000000000000000000000111   7
//		//00000000000000000000000000000110   6
//		//00000000000000000000000000000101   5
//		//00000000000000000000000000000100   4
//		//00000000000000000000000000000011   3
//		//00000000000000000000000000000010   2
//		//00000000000000000000000000000001   1
//		//00000000000000000000000000000000   0
//		//11111111111111111111111111111111   4294967295
//	}
//	return 0;
//}

//6
//#include <string.h>
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//a[0] = -1;
//		//a[1] = -2;
//		//a[2] = -3;
//		//a[3] = -4;
//		//a[4] = -5;
//		//a[5] = -6;
//		//a[6] = -7;
//		//a[7] = -8;
//		//a[8] = -9;
//		//.....
//		//a[128] = -127;
//		//a[129] = -128;
//		// 127 126 125 ...124...3 2 1 0 -1 -2...-127 -128 127
//	}
//	printf("%d", strlen(a));//找\0->找0；//255
//	return 0;
//}

//7
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		//00000000
//		//00000001
//		//00000010
//		//00000011
//		//00000100
//		//...
//		//11111111
//		printf("hello world\n");//死循环
//	}
//	return 0;
//}



//浮点型在内存的存储

//#include <limits.h>
//int main()
//{
//	INT_MAX;
//}

//int main()
//{
//	int n = 9;//4byte
//	float* pFLoat = (float*)&n;
//	printf("n的值为:%d\n", n); //9
//	printf("*pFLoat的值为:%f\n", *pFLoat);//0.000000
//
//	*pFLoat = 9.0;
//	printf("num的值为:%d\n", n);//1091567616
//	printf("*pFLoat的值为:%f\n", *pFLoat);//9.000000
//	return 0;
//}//浮点数和整数在内存中的存储方式不一样


//任意一个二进制浮点数V可以表示为
// IEEE 754标准(电气和电子工程协会)
// * (-1)^S*M*2^E
// * (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
// * M表示有效数字，大于等于1，小于2。
// * 2^E表示指数位

//比如
//浮点数 5.5 -10进制
//二进制 101.1 -- 1.011*2^2  ->  1.011*2^2
//									s=0 M=1.011 E=2\
//对于float  s(1bit) E(8bit) M(23bit) //M丢弃第一位
//对于double s(1bit) E(11bit) M(52bit) //E可能是负值要加中间值修复

//放进去的方法
//int main()
//{
//	float  f = 5.5f;
//	//101.1
//	//1.011*2^2  1.011*2^2
//	//s=0 M=1.011 E=2
//	//真实存进去的数据s=0 E=2+127 M=011(存小数点后面的)
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//40 b0 00 00
//	return 0;
//}

//取出的方法
//1 
// E不全为0或不全为1 
// 采用E计算值减去127(double为1023)，得到真实值，再将有效数字M前加上第一位的1
//2
// E为全0
//规定E=1-127(或1-1023)即为真实值，意味着真实的E非常小无限趋近0。有效数字M不再加上第一位的1，而是还原为0.xxxxxxxx的小数
//3
//E为全1
//这时，如果有效数字M全为0，表示+-无穷大(正负取决与符号位s)


int main()
{
	//1001=1.001*2^3  
	int n = 9;//4byte
	//0 00000000 00000000000000000001001
	float* pfloat = (float*)&n;
	printf("n的值为:%d\n", n); //9
	printf("*pfloat的值为:%f\n", *pfloat);//0.000000 E全0

	*pfloat = 9.0;
	//E=3+127=130
	//0 10000010 00100000000000000000000
	printf("num的值为:%d\n", n);//1091567616
	printf("*pfloat的值为:%f\n", *pfloat);//9.000000
	return 0;
}